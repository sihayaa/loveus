<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Middle-earth Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#1a140f; --ink:#d7c6a3; --ring:#bfa35a;
      --shadow:0 18px 55px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.06);
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{
      margin:0; overflow:hidden; user-select:none;
      background: radial-gradient(1200px 800px at 70% 10%, #2a221b, #15100b 70%, #0d0a07 100%), var(--bg);
      color:var(--ink); font-family: ui-serif, Georgia, "Times New Roman", serif;
    }
    /* particles BEHIND the map */
    #particles{position:fixed; inset:0; z-index:1; pointer-events:none}

    /* Header */
    .topbar{position:fixed; inset:12px 12px auto 12px; z-index:10; display:flex; gap:12px; align-items:center}
    .chip{
      display:inline-flex; align-items:center; gap:8px; padding:7px 10px;
      border:1px solid rgba(191,163,90,.5); border-radius:10px;
      background:rgba(32,26,20,.6); color:var(--ink); box-shadow:var(--shadow);
      text-decoration:none; font-size:13px; cursor:pointer;
    }
    .chip:hover{background:rgba(50,40,30,.75)}
    .title{
      flex:1; text-align:center; font-family:"Cinzel",serif; font-weight:700;
      letter-spacing:.5px; font-size:28px; text-shadow:0 0 8px rgba(255,231,160,.2);
    }

    /* Map viewer (over particles) */
    .viewport{position:absolute; inset:64px 0 0 0; z-index:2; overflow:hidden; touch-action:none}
    .map-inner{position:absolute; top:0; left:0; transform-origin:0 0; will-change:transform}
    .map-img{
      display:block; width:100%; height:auto; pointer-events:none;
      filter:contrast(1.02) brightness(.96) sepia(.08);
      box-shadow:var(--shadow); border-radius:4px;
    }
  </style>
</head>
<body>
  <!-- background particles -->
  <canvas id="particles"></canvas>

  <!-- header -->
  <div class="topbar">
    <a class="chip" href="javascript:history.back()">⟵ Back Home</a>
    <div class="title">MIDDLE-EARTH MAP</div>
    <a class="chip" href="#" onclick="resetView(); return false;">Reset View</a>
  </div>

  <!-- map -->
  <div id="viewport" class="viewport">
    <div id="mapInner" class="map-inner">
      <img id="mapImg" class="map-img" alt="Map"
           src="https://raw.githubusercontent.com/sihayaa/loveus/refs/heads/main/mem_map.png" />
    </div>
  </div>

<script>
/* ========= Smooth pan/zoom camera ========= */
const viewport = document.getElementById('viewport');
const mapInner = document.getElementById('mapInner');
const mapImg   = document.getElementById('mapImg');

const FIT = 0.82;
const ZOOM_SMOOTH = 0.24; // 0.18–0.3
const cam = { x:0,y:0,s:1, tx:0,ty:0,ts:1, sMin:0.45, sMax:3.5, dragging:false, lx:0, ly:0, natW:2048, natH:1536 };

mapImg.addEventListener('load', ()=>{
  cam.natW = mapImg.naturalWidth || cam.natW;
  cam.natH = mapImg.naturalHeight || cam.natH;
  centerFit();
});
function centerFit(){
  const vw=viewport.clientWidth, vh=viewport.clientHeight;
  const s=Math.min(vw/cam.natW, vh/cam.natH)*FIT;
  cam.s = cam.ts = s;
  cam.x = cam.tx = vw/2 - (cam.natW*s)/2;
  cam.y = cam.ty = vh/2 - (cam.natH*s)/2;
  applyCam();
}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function applyCam(){ mapInner.style.transform = `matrix(${cam.s},0,0,${cam.s},${cam.x},${cam.y})`; }
function zoomAt(cx,cy,newScale){
  newScale = clamp(newScale, cam.sMin, cam.sMax);
  const r = viewport.getBoundingClientRect();
  const wx = (cx - r.left - cam.x) / cam.s;
  const wy = (cy - r.top  - cam.y) / cam.s;
  cam.ts = newScale;
  cam.tx = cx - r.left - wx * newScale;
  cam.ty = cy - r.top  - wy * newScale;
}
viewport.addEventListener('pointerdown', e=>{ cam.dragging=true; cam.lx=e.clientX; cam.ly=e.clientY; viewport.setPointerCapture(e.pointerId); });
viewport.addEventListener('pointermove', e=>{
  if(!cam.dragging) return;
  const dx=e.clientX-cam.lx, dy=e.clientY-cam.ly;
  cam.tx+=dx; cam.ty+=dy; cam.lx=e.clientX; cam.ly=e.clientY;
});
viewport.addEventListener('pointerup', e=>{ cam.dragging=false; viewport.releasePointerCapture(e.pointerId); });
viewport.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor=(e.deltaY<0)?1.08:0.92;
  zoomAt(e.clientX,e.clientY, cam.ts*factor);
},{passive:false});
function resetView(){ centerFit(); }
addEventListener('resize', ()=>{ centerFit(); });

// camera easing (dt-clamped so it never jumps after background tab)
let lastCam = performance.now();
function animateCam(now){
  const dt = Math.min( (now - lastCam) / 16.6667, 2 );
  lastCam = now;
  const t = 1 - Math.pow(1 - ZOOM_SMOOTH, dt);
  cam.x += (cam.tx - cam.x) * t;
  cam.y += (cam.ty - cam.y) * t;
  cam.s += (cam.ts - cam.s) * t;
  applyCam();
  requestAnimationFrame(animateCam);
}
requestAnimationFrame(animateCam);

/* ========= Lightweight snowfall (runes + star glyphs only) ========= */
/* No emoji leaves, no glowing embers, no per-frame text drawing.
   Each symbol is pre-rendered once to a tiny canvas sprite and then blitted. */

const GOLD = "#d4af37";
const glyphs = ["✶","✷","✸","✹","✺","✧","✦","✳"];
const runes  = ["ᚠ","ᚱ","ᛃ","ᚨ","ᛟ","ᛞ","ᚾ","ᛋ"];
const SYMBOLS = glyphs.concat(runes);

const canvas = document.getElementById('particles');
const ctx    = canvas.getContext('2d');

// modest DPR cap keeps it crisp but fast
let W=0,H=0;
function sizeCanvas(){
  const dpr = Math.min(window.devicePixelRatio || 1, 1.5);
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width  = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  W = innerWidth; H = innerHeight;
}
addEventListener('resize', sizeCanvas); sizeCanvas();

/* Tweak these */
const FLAKE_COUNT = 220;   // density (160–280)
const FALL_SPEED  = 2.4;   // overall fall speed
const DRIFT       = 0.35;  // horizontal sway (0.25–0.45)
const EDGE        = 100;   // off-screen spawn/wrap bleed

/* Sprite cache: key = "char@size" => canvas */
const spriteCache = new Map();
function getSprite(char, size){
  const key = char+"@"+size;
  if (spriteCache.has(key)) return spriteCache.get(key);
  const pad = Math.ceil(size*0.55);
  const s   = document.createElement('canvas');
  s.width = s.height = size + pad*2;
  const c = s.getContext('2d');
  c.textAlign="center"; c.textBaseline="middle";
  c.font = `${size}px "Noto Sans Symbols 2","Noto Sans Runic","Segoe UI Symbol","Symbola","Noto Sans",serif`;
  // one-time paint (fill + thin stroke) into the sprite
  c.fillStyle = GOLD;
  c.fillText(char, s.width/2, s.height/2);
  c.strokeStyle = "rgba(0,0,0,0.28)";
  c.lineWidth = Math.max(1, size*0.06);
  c.strokeText(char, s.width/2, s.height/2);
  spriteCache.set(key, s);
  return s;
}

/* Particles */
const flakes = [];
function makeFlake(){
  const char = SYMBOLS[(Math.random()*SYMBOLS.length)|0];
  const size = Math.round(16 + Math.random()*10); // 16..26px
  const sprite = getSprite(char, size);
  return {
    x: Math.random()*(W+EDGE*2) - EDGE,
    y: -20 - Math.random()*(H+EDGE),
    vy: (0.6 + Math.random()*0.5) * FALL_SPEED,     // natural, a bit varied
    swayPhase: Math.random()*Math.PI*2,
    swaySpeed: 0.8 + Math.random()*0.6,             // individual sway rate
    alpha: 0.95,
    sprite
  };
}
for(let i=0;i<FLAKE_COUNT;i++) flakes.push(makeFlake());

// freeze sim while tab hidden so it never “jumps”
let last = performance.now();
document.addEventListener('visibilitychange', ()=>{ last = performance.now(); });

function step(now){
  requestAnimationFrame(step);
  if (document.hidden) { last = now; return; }
  let dt = (now - last) / 16.6667;             // 60fps units
  dt = Math.max(0.5, Math.min(dt, 1.2));       // clamp for stability
  last = now;

  ctx.clearRect(0,0,W,H);

  const breeze = Math.sin(now * 0.00035) * DRIFT; // shared wind

  for (let i=0;i<flakes.length;i++){
    const f = flakes[i];
    f.swayPhase += f.swaySpeed * 0.02 * dt;
    f.x += (Math.sin(f.swayPhase) * (DRIFT*0.9) + breeze) * dt * 16;
    f.y += f.vy * dt;

    // wrap with bleed
    if (f.y > H + EDGE){ const nf = makeFlake(); nf.y = -EDGE; flakes[i] = nf; continue; }
    if (f.x < -EDGE) f.x = W + EDGE;
    if (f.x > W + EDGE) f.x = -EDGE;

    // draw pre-rendered sprite (no save/restore, no text layout)
    const s = f.sprite;
    ctx.globalAlpha = f.alpha;
    ctx.drawImage(s, f.x - s.width/2, f.y - s.height/2);
  }
  ctx.globalAlpha = 1;
}
requestAnimationFrame(step);
</script>
</body>
</html>
