<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Middle-earth Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#1a140f; --ink:#d7c6a3; --ring:#bfa35a;
      --shadow:0 18px 55px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.06);
    }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0; overflow:hidden; user-select:none;
      background: radial-gradient(1200px 800px at 70% 10%, #2a221b, #15100b 70%, #0d0a07 100%), var(--bg);
      color:var(--ink); font-family: ui-serif, Georgia, "Times New Roman", serif;}

    /* particles sit BEHIND the map */
    #particles{position:fixed; inset:0; z-index:1; pointer-events:none}

    .topbar{position:fixed; inset:12px 12px auto 12px; z-index:10; display:flex; gap:12px; align-items:center}
    .chip{display:inline-flex; align-items:center; gap:8px; padding:7px 10px; border:1px solid rgba(191,163,90,.5);
      border-radius:10px; background:rgba(32,26,20,.6); color:var(--ink); box-shadow:var(--shadow); text-decoration:none; font-size:13px}
    .chip:hover{background:rgba(50,40,30,.75)}
    .title{flex:1; text-align:center; font-family:"Cinzel",serif; font-weight:700; letter-spacing:.5px; font-size:28px; text-shadow:0 0 8px rgba(255,231,160,.2)}

    .viewport{position:absolute; inset:64px 0 0 0; z-index:2; overflow:hidden; touch-action:none}
    .map-inner{position:absolute; top:0; left:0; transform-origin:0 0; will-change:transform}
    .map-img{display:block; width:100%; height:auto; pointer-events:none; filter:contrast(1.02) brightness(.96) sepia(.08); box-shadow:var(--shadow); border-radius:4px}
  </style>
</head>
<body>
  <canvas id="particles"></canvas>

  <div class="topbar">
    <a class="chip" href="javascript:history.back()">‚üµ Back Home</a>
    <div class="title">MIDDLE-EARTH MAP</div>
    <a class="chip" href="#" onclick="resetView(); return false;">Reset View</a>
  </div>

  <div id="viewport" class="viewport">
    <div id="mapInner" class="map-inner">
      <img id="mapImg" class="map-img" alt="Map"
           src="https://raw.githubusercontent.com/sihayaa/loveus/refs/heads/main/mem_map.png" />
    </div>
  </div>

<script>
/* ===== Smooth pan/zoom camera ===== */
const viewport = document.getElementById('viewport');
const mapInner = document.getElementById('mapInner');
const mapImg   = document.getElementById('mapImg');

const FIT = 0.82;
const ZOOM_SMOOTH = 0.24; // easing strength
const cam = { x:0,y:0,s:1, tx:0,ty:0,ts:1, sMin:0.45, sMax:3.5, dragging:false, lx:0, ly:0, natW:2048, natH:1536 };

mapImg.addEventListener('load', ()=>{
  cam.natW = mapImg.naturalWidth || cam.natW;
  cam.natH = mapImg.naturalHeight || cam.natH;
  centerFit(true);
});
function centerFit(){
  const vw=viewport.clientWidth, vh=viewport.clientHeight;
  const s=Math.min(vw/cam.natW, vh/cam.natH)*FIT;
  cam.s = cam.ts = s;
  cam.x = cam.tx = vw/2 - (cam.natW*s)/2;
  cam.y = cam.ty = vh/2 - (cam.natH*s)/2;
  applyCam();
}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function applyCam(){ mapInner.style.transform = `matrix(${cam.s},0,0,${cam.s},${cam.x},${cam.y})`; }
function zoomAt(cx,cy,newScale){
  newScale = clamp(newScale, cam.sMin, cam.sMax);
  const r = viewport.getBoundingClientRect();
  const wx = (cx - r.left - cam.x) / cam.s;
  const wy = (cy - r.top  - cam.y) / cam.s;
  cam.ts = newScale;
  cam.tx = cx - r.left - wx * newScale;
  cam.ty = cy - r.top  - wy * newScale;
}
viewport.addEventListener('pointerdown', e=>{ cam.dragging=true; cam.lx=e.clientX; cam.ly=e.clientY; viewport.setPointerCapture(e.pointerId); });
viewport.addEventListener('pointermove', e=>{
  if(!cam.dragging) return;
  const dx=e.clientX-cam.lx, dy=e.clientY-cam.ly;
  cam.tx+=dx; cam.ty+=dy; cam.lx=e.clientX; cam.ly=e.clientY;
});
viewport.addEventListener('pointerup', e=>{ cam.dragging=false; viewport.releasePointerCapture(e.pointerId); });
viewport.addEventListener('wheel', e=>{
  e.preventDefault();
  const factor=(e.deltaY<0)?1.08:0.92;
  zoomAt(e.clientX,e.clientY, cam.ts*factor);
},{passive:false});
function resetView(){ centerFit(); }
addEventListener('resize', ()=>{ centerFit(); });

// camera easing with dt clamp so it never ‚Äújumps‚Äù
let lastCam = performance.now();
function animateCam(now){
  const dt = Math.min( (now - lastCam) / 16.6667, 2 ); // clamp big deltas
  lastCam = now;
  const t = 1 - Math.pow(1 - ZOOM_SMOOTH, dt);
  cam.x += (cam.tx - cam.x) * t;
  cam.y += (cam.ty - cam.y) * t;
  cam.s += (cam.ts - cam.s) * t;
  applyCam();
  requestAnimationFrame(animateCam);
}
requestAnimationFrame(animateCam);

/* ===== Background particles (fast, smooth, continuous) ===== */
const palette = { gold:"#d4af37", ember:"rgba(255,140,60,.9)", leaf:"#b6a47a" };
const glyphs  = ["‚ú∂","‚ú∑","‚ú∏","‚úπ","‚ú∫","‚úß","‚ú¶","‚ú≥"]; // bursts
const runes   = ["·ö†","·ö±","·õÉ","·ö®","·õü","·õû","·öæ","·õã"];
const leaves  = ["üçÇ","üçÅ"];

const canvas = document.getElementById('particles');
const ctx    = canvas.getContext('2d');

let W=0,H=0;
function sizeCanvas(){
  const dpr = Math.min(window.devicePixelRatio || 1, 1.5); // cap DPR for perf
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width  = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  W = innerWidth; H = innerHeight;
}
addEventListener('resize', sizeCanvas); sizeCanvas();

// density / speed / edge bleed
const FLAKE_COUNT = 240;   // adjust for density
const EDGE        = 120;   // off-screen bleed
const FALL_SPEED  = 2.6;   // global speed (‚Üë faster)

// particles
const flakes=[];
function makeFlake(){
  const k=Math.random();
  let type,char,color,size;
  if (k<.34){ type='rune';  char=runes[(Math.random()*runes.length)|0];  color=palette.gold; size=14+Math.random()*8; }
  else if (k<.67){ type='leaf'; char=leaves[(Math.random()*leaves.length)|0]; color=palette.leaf; size=16+Math.random()*10; }
  else { type='ember'; char="‚Ä¢"; color=palette.ember; size=3+Math.random()*2; }
  return {
    x: Math.random()*(W+EDGE*2)-EDGE,
    y: -20 - Math.random()*(H+EDGE),
    vy: (0.5 + Math.random()*0.7) * FALL_SPEED,
    drift: 0.2 + Math.random()*0.4,
    phase: Math.random()*Math.PI*2,
    rot: Math.random()*Math.PI, spin:(Math.random()-0.5)*0.02,
    type,char,color,size, alpha: type==='ember'?0.8:0.95
  };
}
for(let i=0;i<FLAKE_COUNT;i++) flakes.push(makeFlake());

// bursts
const bursts=[];
function burst(x,y){
  const n=18;
  for(let i=0;i<n;i++){
    bursts.push({
      x,y,
      vx: Math.cos((i/n)*Math.PI*2)*(1.5+Math.random()*1.2),
      vy: Math.sin((i/n)*Math.PI*2)*(1.5+Math.random()*1.2) - 0.6,
      life:1, char:glyphs[i%glyphs.length], size:10+Math.random()*10
    });
  }
}
addEventListener('click', e=> burst(e.clientX, e.clientY));

function fontFor(px){
  return `${px}px "Noto Sans Symbols 2","Noto Sans Runic","Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji","Segoe UI Symbol","Symbola","Noto Sans",serif`;
}

// dt clamp + visibility guard so it never ‚Äújumps‚Äù after tab switch
let last = performance.now();
document.addEventListener('visibilitychange', ()=>{ last = performance.now(); });

function step(now){
  requestAnimationFrame(step);

  // clamp dt so background tab throttling can't create huge jumps
  let dt = (now - last) / 16.6667;           // 60fps units
  if (document.hidden) { last = now; return; } // freeze while hidden
  dt = Math.max(0.1, Math.min(dt, 1.5));     // smooth bounds
  last = now;

  ctx.clearRect(0,0,W,H);
  const breeze = Math.sin(now*0.00045) * 0.45; // shared wind

  // flakes
  for (let i=0;i<flakes.length;i++){
    const f = flakes[i];
    f.phase += 0.012 * dt;
    f.x += (Math.sin(f.phase)*f.drift + breeze) * dt;
    f.y += f.vy * dt;
    f.rot += f.spin * dt;

    // wrap with edge bleed
    if (f.y > H + EDGE){ const nf = makeFlake(); nf.y = -EDGE; flakes[i] = nf; continue; }
    if (f.x < -EDGE) f.x = W + EDGE;
    if (f.x > W + EDGE) f.x = -EDGE;

    if (f.type==='ember'){
      ctx.save(); ctx.globalAlpha=f.alpha;
      ctx.beginPath(); ctx.arc(f.x,f.y,f.size,0,Math.PI*2);
      ctx.fillStyle=f.color; ctx.shadowColor=f.color; ctx.shadowBlur=2; // low blur = faster
      ctx.fill(); ctx.shadowBlur=0; ctx.restore();
    }else{
      ctx.save(); ctx.translate(f.x,f.y); ctx.rotate(f.rot);
      ctx.globalAlpha=f.alpha; ctx.fillStyle=f.color;
      ctx.font = fontFor(f.size);
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(f.char,0,0);
      ctx.restore();
    }
  }

  // bursts
  for (let i=bursts.length-1;i>=0;i--){
    const b = bursts[i];
    b.x += b.vx * dt; b.y += b.vy * dt; b.vy += 0.02 * dt;
    b.life -= 0.02 * dt;

    ctx.save(); ctx.globalAlpha=Math.max(b.life,0);
    ctx.fillStyle=palette.gold;
    ctx.font=fontFor(b.size*(0.9+b.life*0.6));
    ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.fillText(b.char,b.x,b.y); ctx.restore();

    if (b.life<=0) bursts.splice(i,1);
  }
}
requestAnimationFrame(step);
</script>
</body>
</html>

