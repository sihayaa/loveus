<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Middle-earth Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Optional display fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#1a140f; --ink:#d7c6a3; --ring:#bfa35a;
      --shadow:0 18px 55px rgba(0,0,0,.5), inset 0 1px 0 rgba(255,255,255,.06);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden; user-select:none;
      background: radial-gradient(1200px 800px at 70% 10%, #2a221b, #15100b 70%, #0d0a07 100%), var(--bg);
      color:var(--ink); font-family: ui-serif, Georgia, "Times New Roman", serif;
    }

    /* BACKGROUND particles (behind the map) */
    #particles{position:fixed; inset:0; z-index:1; pointer-events:none}

    /* Header */
    .topbar{
      position:fixed; inset:12px 12px auto 12px; z-index:10;
      display:flex; gap:12px; align-items:center;
    }
    .chip{
      display:inline-flex; align-items:center; gap:8px; padding:7px 10px;
      border:1px solid rgba(191,163,90,.5); border-radius:10px;
      background:rgba(32,26,20,.6); color:var(--ink); box-shadow:var(--shadow);
      text-decoration:none; font-size:13px; cursor:pointer;
    }
    .chip:hover{background:rgba(50,40,30,.75)}
    .title{
      flex:1; text-align:center; font-family:"Cinzel",serif; font-weight:700;
      letter-spacing:.5px; font-size:28px; text-shadow:0 0 8px rgba(255,231,160,.2);
    }

    /* Map viewer (over particles) */
    .viewport{position:absolute; inset:64px 0 0 0; z-index:2; overflow:hidden; touch-action:none}
    .map-inner{position:absolute; top:0; left:0; transform-origin:0 0; will-change:transform}
    .map-img{
      display:block; width:100%; height:auto; pointer-events:none;
      filter:contrast(1.02) brightness(.96) sepia(.08);
      box-shadow:var(--shadow); border-radius:4px;
    }
  </style>
</head>
<body>
  <!-- background particles -->
  <canvas id="particles"></canvas>

  <!-- header -->
  <div class="topbar">
    <a class="chip" href="javascript:history.back()">‚üµ Back Home</a>
    <div class="title">MIDDLE-EARTH MAP</div>
    <a class="chip" href="#" onclick="resetView(); return false;">Reset View</a>
  </div>

  <!-- map -->
  <div id="viewport" class="viewport">
    <div id="mapInner" class="map-inner">
      <img id="mapImg" class="map-img" alt="Map"
           src="https://raw.githubusercontent.com/sihayaa/loveus/refs/heads/main/mem_map.png" />
    </div>
  </div>

  <script>
    /* ========= Map pan/zoom ========= */
    const viewport = document.getElementById('viewport');
    const mapInner = document.getElementById('mapInner');
    const mapImg   = document.getElementById('mapImg');

    const FIT_FACTOR = 0.82;
    const st = { scale:1, min:.45, max:3.5, tx:0, ty:0, dragging:false, lx:0, ly:0, nw:1000, nh:1000 };

    mapImg.addEventListener('load', () => {
      st.nw = mapImg.naturalWidth; st.nh = mapImg.naturalHeight;
      centerFit(); applyTransform();
    });

    function centerFit(){
      const vw = viewport.clientWidth, vh = viewport.clientHeight;
      const s = Math.min(vw/st.nw, vh/st.nh) * FIT_FACTOR;
      st.scale = s;
      st.tx = vw/2 - (st.nw*s)/2;
      st.ty = vh/2 - (st.nh*s)/2;
    }
    function applyTransform(){
      mapInner.style.transform = `translate(${st.tx}px, ${st.ty}px) scale(${st.scale})`;
    }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    viewport.addEventListener('pointerdown', e => {
      st.dragging = true; st.lx = e.clientX; st.ly = e.clientY;
      viewport.setPointerCapture(e.pointerId);
    });
    viewport.addEventListener('pointermove', e => {
      if(!st.dragging) return;
      const dx = e.clientX - st.lx, dy = e.clientY - st.ly;
      st.tx += dx; st.ty += dy; st.lx = e.clientX; st.ly = e.clientY; applyTransform();
    });
    viewport.addEventListener('pointerup', e => {
      st.dragging = false; viewport.releasePointerCapture(e.pointerId);
    });
    viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const factor = (e.deltaY < 0) ? 1.08 : 0.92;
      const ns = clamp(st.scale * factor, st.min, st.max);
      const r = viewport.getBoundingClientRect();
      const x = (e.clientX - r.left - st.tx) / st.scale;
      const y = (e.clientY - r.top  - st.ty) / st.scale;
      st.tx = e.clientX - r.left - x * ns;
      st.ty = e.clientY - r.top  - y * ns;
      st.scale = ns; applyTransform();
    }, {passive:false});
    function resetView(){ centerFit(); applyTransform(); }
    window.addEventListener('resize', () => { centerFit(); applyTransform(); });

    /* ========= Background particles =========
       EXACT symbol sets + your flake/burst approach
    */
    const palette = { gold:"#d4af37", ember:"rgba(255,140,60,.9)", leaf:"#b6a47a" };
    const glyphs  = ["‚ú∂","‚ú∑","‚ú∏","‚úπ","‚ú∫","‚úß","‚ú¶","‚ú≥"];           // bursts
    const runes   = ["·ö†","·ö±","·õÉ","·ö®","·õü","·õû","·öæ","·õã"];           // falling
    const leaves  = ["üçÇ","üçÅ"];                                    // falling

    const canvas = document.getElementById('particles');
    const ctx    = canvas.getContext('2d');

    // Hi-DPI scaling so symbols look crisp
    let W=0, H=0;
    function sizeCanvas(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      canvas.width  = Math.floor(innerWidth * dpr);
      canvas.height = Math.floor(innerHeight * dpr);
      canvas.style.width  = innerWidth + 'px';
      canvas.style.height = innerHeight + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
      W = innerWidth; H = innerHeight;
    }
    window.addEventListener('resize', sizeCanvas);
    sizeCanvas();

    // Density + edge-bleed so flakes truly occupy the sides
    const FLAKE_COUNT = 260;   // ‚¨Ö make higher for more density (e.g. 320)
    const EDGE = 100;          // ‚¨Ö off-screen bleed (left/right/top/bottom)

    const flakes = [];
    function makeFlake() {
      const kind = Math.random();
      let type, char, color, size;
      if (kind < .34){ type='rune';  char = runes[(Math.random()*runes.length)|0];  color = palette.gold; size = 14 + Math.random()*8; }
      else if (kind < .67){ type='leaf'; char = leaves[(Math.random()*leaves.length)|0]; color = palette.leaf; size = 16 + Math.random()*10; }
      else { type='ember'; char="‚Ä¢"; color = palette.ember; size = 3 + Math.random()*2; }

      return {
        x: Math.random() * (W + EDGE*2) - EDGE,  // spawn from -EDGE..W+EDGE
        y: -20 - Math.random() * (H + EDGE),     // some start well above
        vy: 0.5 + Math.random() * 0.7,           // natural fall
        drift: 0.2 + Math.random() * 0.4,        // gentle personal sway
        phase: Math.random() * Math.PI * 2,
        rot: Math.random() * Math.PI, spin: (Math.random()-0.5) * 0.02,
        type, char, color, size, alpha: type==='ember' ? 0.8 : 0.95
      };
    }
    for (let i=0;i<FLAKE_COUNT;i++) flakes.push(makeFlake());

    // Click bursts (golden glyphs)
    let bursts = [];
    function burst(x,y){
      const n = 18;
      for (let i=0;i<n;i++){
        bursts.push({
          x, y,
          vx: Math.cos((i/n)*Math.PI*2) * (1.5 + Math.random()*1.2),
          vy: Math.sin((i/n)*Math.PI*2) * (1.5 + Math.random()*1.2) - 0.6,
          life: 1,
          char: glyphs[i % glyphs.length],
          size: 10 + Math.random()*10
        });
      }
    }
    // Canvas ignores clicks (pointer-events:none), so listen on window
    window.addEventListener('click', e => burst(e.clientX, e.clientY));

    function fontFor(px){
      // Wide stack to render runes + emoji across OSes
      return `${px}px "Noto Sans Symbols 2","Noto Sans Runic","Segoe UI Emoji","Apple Color Emoji","Noto Color Emoji","Segoe UI Symbol","Symbola","Noto Sans",serif`;
    }

    function step(){
      requestAnimationFrame(step);
      ctx.clearRect(0,0,W,H);

      // gentle breeze so everything moves together
      const t = performance.now() * 0.00015;
      const breeze = Math.sin(t*3) * 0.4;

      // Flakes
      for (let i=0;i<flakes.length;i++){
        const f = flakes[i];
        f.phase += 0.01;
        f.x += Math.sin(f.phase) * f.drift + breeze;
        f.y += f.vy;
        f.rot += f.spin;

        // Wrap using EDGE bleed
        if (f.y > H + EDGE) { const nf = makeFlake(); nf.y = -EDGE; flakes[i] = nf; continue; }
        if (f.x < -EDGE) f.x = W + EDGE;
        if (f.x > W + EDGE) f.x = -EDGE;

        // Draw
        if (f.type === 'ember'){
          ctx.save();
          ctx.globalAlpha = f.alpha;
          ctx.beginPath(); ctx.arc(f.x, f.y, f.size, 0, Math.PI*2);
          ctx.fillStyle = f.color; ctx.shadowColor = f.color; ctx.shadowBlur = 6; ctx.fill();
          ctx.shadowBlur = 0; ctx.restore();
        } else {
          ctx.save();
          ctx.translate(f.x, f.y); ctx.rotate(f.rot);
          ctx.globalAlpha = f.alpha; ctx.fillStyle = f.color;
          ctx.font = fontFor(f.size);
          ctx.textAlign = "center"; ctx.textBaseline = "middle";
          ctx.fillText(f.char, 0, 0);
          ctx.restore();
        }
      }

      // Bursts
      for (let i=bursts.length-1;i>=0;i--){
        const b = bursts[i];
        b.x += b.vx; b.y += b.vy; b.vy += 0.02;   // gravity
        b.life -= 0.02;

        ctx.save();
        ctx.globalAlpha = Math.max(b.life, 0);
        ctx.fillStyle = palette.gold;
        ctx.font = fontFor(b.size * (0.9 + b.life*0.6));
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText(b.char, b.x, b.y);
        ctx.restore();

        if (b.life <= 0) bursts.splice(i,1);
      }
    }
    step();
  </script>
</body>
</html>
